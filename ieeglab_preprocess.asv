function EEG = ieeglab_preprocess(EEG)

% GUI to get user choices
if nargin < 2
    [EEG, wasCancelled] = ieeglab_gui_preprocess(EEG);
    if wasCancelled
        return  % user aborted, exit gracefully
    end
end

opt = EEG.ieeglab.opt;

%  Gather events safely (table form + remember original form)
ev_tbl = table();  % default empty
ev_from_opt = isfield(opt,'events') && istable(opt.events) && ~isempty(opt.events);

if ev_from_opt
    ev_tbl = opt.events;
else
    if isfield(EEG,'event') && ~isempty(EEG.event)
        if istable(EEG.event)
            ev_tbl = EEG.event;
        elseif isstruct(EEG.event)
            try, ev_tbl = struct2table(EEG.event, 'AsArray', true); catch, ev_tbl = table(); end
        end
    end
end
events_exist = istable(ev_tbl) && ~isempty(ev_tbl);
event_was_struct = isfield(EEG,'event') && isstruct(EEG.event) && ~isempty(EEG.event);

%  Filter events of interest (if any) 
if isfield(opt,'event_filters') && ~isempty(fieldnames(opt.event_filters)) && events_exist
    ev_choices = opt.event_filters;
    vars = fieldnames(ev_choices);

    % Normalize all columns we might touch into string view on-the-fly
    keepMask = true(height(ev_tbl),1);

    for iField = 1:numel(vars)
        col = vars{iField};
        labelsToKeep = ev_choices.(col);  % cellstr or string, {} means "All"
        if isempty(labelsToKeep) || ~ismember(col, ev_tbl.Properties.VariableNames)
            continue; % nothing to filter on this column
        end

        % normalize both side types to string (case-insensitive compare)
        colVals = ev_tbl.(col);
        if iscell(colVals), colVals = string(colVals); end
        if iscategorical(colVals), colVals = string(colVals); end
        if isnumeric(colVals), colVals = string(colVals); end
        colVals = lower(colVals);

        lab = labelsToKeep;
        if iscell(lab), lab = string(lab); end
        lab = lower(string(lab(:)));

        thisKeep = ismember(colVals, lab);
        % Report removal count at this stage (before combining with other filters)
        nToRemoveHere = sum(~thisKeep & keepMask);
        if nToRemoveHere > 0
            lab_disp = strjoin(cellstr(unique(lab,'stable')) , ', ');
            fprintf('Filtering by %s: removing %d events NOT in {%s}\n', col, nToRemoveHere, lab_disp);
        end
        keepMask = keepMask & thisKeep;
    end

    % Apply final mask to table and EEG.event (if present)
    nRemoved = sum(~keepMask);
    if nRemoved > 0
        ev_tbl = ev_tbl(keepMask, :);
        if isfield(EEG,'event') && ~isempty(EEG.event)
            if istable(EEG.event)
                EEG.event = EEG.event(keepMask, :);
            elseif isstruct(EEG.event)
                EEG.event = EEG.event(keepMask);
            end
        end
        fprintf('Total events removed after all filters: %d\n', nRemoved);
    end
end

% Drop heavy event table from options if it exists (safe)
if isfield(EEG.ieeglab,'opt') && isfield(EEG.ieeglab.opt,'events')
    EEG.ieeglab.opt = rmfield(EEG.ieeglab.opt, 'events');
end

% If we sourced events from opt.events and EEG.event was empty, push them back
if ev_from_opt && events_exist && (~isfield(EEG,'event') || isempty(EEG.event))
    EEG.event = table2struct(ev_tbl);
end

% Remove electrodes with no coordinates (optional) 
if isfield(opt, 'remove_no_coords') && opt.remove_no_coords && isfield(EEG,'chanlocs') && ~isempty(EEG.chanlocs)
    hasXYZ = arrayfun(@(c) isfield(c,'X') && isfield(c,'Y') && isfield(c,'Z') && ...
        ~isempty(c.X) && ~isempty(c.Y) && ~isempty(c.Z) && ...
        all(isfinite([c.X c.Y c.Z])), EEG.chanlocs);

    removedLabels = {EEG.chanlocs(~hasXYZ).labels};  % for logging
    if any(~hasXYZ)
        warning('Removing %d channels with no coordinates: %s\n', ...
            nnz(~hasXYZ), strjoin(removedLabels, ', '));
        keepChanIdx = find(hasXYZ);
        EEG = pop_select(EEG, 'channel', keepChanIdx);
        EEG = eeg_checkset(EEG);
    else
        removedLabels = {};
    end

    % Remove corresponding events whose TYPE includes any removed label (if events exist)
    if ~isempty(removedLabels) && isfield(EEG,'event') && ~isempty(EEG.event)
        [evTypes, okTypes] = local_get_event_types(EEG.event);
        if okTypes
            remEv = false(size(evTypes));
            lowRemoved = lower(string(removedLabels));
            for k = 1:numel(lowRemoved)
                remEv = remEv | contains(evTypes, lowRemoved(k));
            end
            if any(remEv)
                warning("Removing %g events containing removed-electrode labels.", sum(remEv))
                if istable(EEG.event)
                    EEG.event = EEG.event(~remEv, :);
                else
                    EEG.event = EEG.event(~remEv);
                end
                EEG = eeg_checkset(EEG);
            end
        end
    end
end

% Remove events pointing to electrodes not present (for CCEP data)
if isfield(EEG,'event') && ~isempty(EEG.event) && isfield(EEG,'chanlocs') ...
    && ~isempty(EEG.chanlocs) && ~isnumeric(EEG.event(1).type)
    % [evTypes, okTypes] = local_get_event_types(EEG.event);
    evTypes = {EEG.event.type};
    if contains(evTypes, '-')
        present = lower(string({EEG.chanlocs.labels}));
        idx = ~arrayfun(@(t) any(contains(t, present)), evTypes);
        if any(idx)
            warning("Removing %g events containing an electrode not in EEG.chanlocs:", sum(idx))
            disp(unique(cellstr(evTypes(idx))))
            if istable(EEG.event)
                EEG.event(idx, :) = [];
            else
                EEG.event(idx) = [];
            end
        end
    end
end


% Downsample
if isfield(opt, 'downsample') && ~isempty(opt.downsample) && opt.downsample<EEG.srate
    fprintf("Downsampling iEEG data to %g Hz... \n", opt.downsample)
    EEG = pop_resample(EEG, opt.downsample);
end

% Global filter type -> minphase flag for pop_eegfiltnew
minphase = false;  % default = noncausal zero-phase
if isfield(opt,'filter_type') && ~isempty(opt.filter_type)
    idx = round(double(opt.filter_type));
    minphase = (idx == 2);   % 1=noncausal, 2=minimum-phase
elseif isfield(opt,'filter_type_label') && ~isempty(opt.filter_type_label)
    lbl = lower(string(opt.filter_type_label));
    if contains(lbl,'minimum') || contains(lbl,'causal')
        minphase = true;
    elseif contains(lbl,'noncausal') || contains(lbl,'zero')
        minphase = false;
    end
end

% High-pass filter
if isfield(opt,'apply_highpass') && opt.apply_highpass && isfield(opt,'highpass') ...
        && ~isempty(opt.highpass) && opt.highpass > 0
    EEG = pop_eegfiltnew(EEG, 'locutoff', double(opt.highpass), 'usefftfilt', 1, 'minphase', minphase);
end

% Notch filter
if isfield(opt,'apply_notch') && opt.apply_notch && isfield(opt,'notch') && ~isempty(opt.notch)
    nyq = EEG.srate/2;
    centers = double(opt.notch(:))';
    BW = 2;                     % total bandwidth (Hz)
    for f0 = centers
        if ~isfinite(f0) || f0<=0 || f0>=nyq, continue; end
        lo = max(0, f0 - BW/2);
        hi = min(nyq-1e-6, f0 + BW/2);
        if hi <= lo, continue; end
        EEG = pop_eegfiltnew(EEG,'locutoff',lo,'hicutoff',hi,'usefftfilt',1,'revfilt',1, 'minphase', minphase);
    end
end

% Low-pass filter
if isfield(opt,'apply_lowpass') && opt.apply_lowpass && isfield(opt,'lowpass') ...
        && ~isempty(opt.lowpass) && opt.lowpass > 0
    lp = double(opt.lowpass);
    nyq = EEG.srate/2;
    if isfinite(lp) && lp > 0 && lp < nyq
        EEG = pop_eegfiltnew(EEG,'hicutoff',lp,'usefftfilt',1, 'minphase', minphase);
    end
end

% Remove conditions with too few trials
if isfield(opt,'remove_rare_cond') && opt.remove_rare_cond && isfield(opt,'min_trials')
    minN = max(0, round(double(opt.min_trials)));
    if minN>0 && isfield(EEG,'event') && ~isempty(EEG.event)
        types = string({EEG.event.type});
        u = unique(types);
        cnt = arrayfun(@(x) sum(types==x), u);
        rm = u(cnt < minN);
        if ~isempty(rm)
            fprintf('Removing %d condition(s) with < %d trials: %s\n', numel(rm), minN, strjoin(cellstr(rm), ', '));
            keep = ~ismember(types, rm);
            EEG.event = EEG.event(keep);
            try EEG = eeg_checkset(EEG,'makeur'); catch, end
        else
            fprintf('No conditions below %d trials.\n', minN);
        end
    end
end


% Epoching (uses ALL current event types if none chosen in GUI) 
if isfield(opt,'apply_epoch') && opt.apply_epoch && ...
   isfield(opt,'epoch_window') && numel(opt.epoch_window)>=2 && ...
   isfield(EEG,'event') && ~isempty(EEG.event)

    % window
    t_ms = double(opt.epoch_window(:))';
    if numel(t_ms)<2 || ~all(isfinite(t_ms(1:2))) || t_ms(2)<=t_ms(1)
        warning('Invalid epoch window; skipping epoching.'); 
    else
        % collect unique event types as strings
        if istable(EEG.event), evTypes = EEG.event.type; else, evTypes = {EEG.event.type}'; end
        if isnumeric(evTypes), evTypes = string(evTypes); end
        if iscell(evTypes),   evTypes = string(evTypes); end
        evtTypes = unique(cellstr(string(evTypes(:))));  % cellstr

        if isempty(evtTypes)
            warning('No event types found to epoch around; skipping.');
        else
            fprintf('Epoching around %d event types, window [%g %g] ms\n', numel(evtTypes), t_ms(1), t_ms(2));
            EEG = pop_epoch(EEG, evtTypes, t_ms/1000, 'epochinfo','yes', 'newname','iEEGLAB epochs');
            EEG = eeg_checkset(EEG);
        end
    end

    % event_filters were only for selection; drop from opts
    if isfield(EEG,'ieeglab') && isfield(EEG.ieeglab,'opt') && isfield(EEG.ieeglab.opt,'event_filters')
        EEG.ieeglab.opt = rmfield(EEG.ieeglab.opt, 'event_filters');
    end
end


% Apply aCAR (Huang et al., 2024) for epoched data
if isfield(opt,'apply_acar') && opt.apply_acar && isfield(EEG,'trials') && EEG.trials>1
    
    % quick visualization (optional)
    respData = nan(length(EEG.times), length(EEG.event));    
    for iTrial = 1:length(EEG.event)
        if ~isnumeric(EEG.event(1).type) && contains(EEG.event(1).type, '-') % for CCEP data
            respElec = extractAfter(EEG.event(iTrial).type, '-');
            respElecIdx = strcmpi({EEG.chanlocs.labels}, respElec);
            respData(:,iTrial) = squeeze(EEG.data(respElecIdx,:,iTrial));
        else
            respData(:,iTrial) = squeeze(trimmean(EEG.data(:,:,iTrial),20,1));
        end
    end
    figure('color','w'); hold on
    plot(EEG.times, trimmean(respData,20,2), 'LineWidth',2)

    EEG = ieeglab_car(EEG);

    respData = nan(length(EEG.times), length(EEG.event));    
    for iTrial = 1:length(EEG.event)
        if ~isnumeric(EEG.event(1).type) && contains(EEG.event(1).type, '-') % for CCEP data
            respElec = extractAfter(EEG.event(iTrial).type, '-');
            respElecIdx = strcmpi({EEG.chanlocs.labels}, respElec);
            respData(:,iTrial) = squeeze(EEG.data(respElecIdx,:,iTrial));
        else
            respData(:,iTrial) = squeeze(trimmean(EEG.data(:,:,iTrial),20,1));
        end
    end
    plot(EEG.times, trimmean(respData,20,2), 'LineWidth',2)
    legend("Before CAR", "After CAR")
end


% Baseline correction
if isfield(opt,'apply_baseline') && opt.apply_baseline
    EEG = ieeglab_rm_baseline(EEG);
end

end



